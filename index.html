<!DOCTYPE html>
<html lang="sl">
<head>
<meta charset="UTF-8">
<title>üé∞ Neon Slot</title>
<style>
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364); color: #fff; text-align: center; margin:0; padding:50px 20px; }
  h1 { font-size: 3em; margin-bottom: 20px; text-shadow: 0 0 10px #00d2ff; }
  
  .grid { display: flex; justify-content: center; gap:12px; margin: 20px auto; }
  
  .column {
    width: 84px;
    height: 248px; /* 3 celice √ó 80px */
    overflow: hidden; /* Skrije vse, kar je zunaj 3 celic */
    border-radius: 15px;
    padding: 2px;
    box-sizing: border-box;
    background: #111;
    border: 1px solid #333;
    position: relative;
  }
  
  .reel {
    display: flex;
    flex-direction: column;
    /* Transformacije upravlja JS */
  }
  
  .cell {
    width: 80px;
    height: 80px;
    flex-shrink: 0; /* Prepreƒçi krƒçenje celic */
    border-radius: 15px;
    border: 2px solid #fff;
    font-size: 28px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #222;
    position: relative;
    box-shadow: 0 0 5px #fff inset;
    margin: 0 auto;
    box-sizing: border-box;
  }
  
  .cell.x { background: gold; color:#000; box-shadow:0 0 15px gold inset, 0 0 20px gold; z-index: 2; }
  .cell.win { background: #39ff14; color:#000; box-shadow:0 0 10px #39ff14 inset, 0 0 20px #39ff14; z-index: 1; }
  
  .subwin {
    position: absolute;
    bottom: 2px;
    right: 2px;
    font-size: 11px;
    color: #000;
    font-weight: 800;
    background: rgba(255,255,255,0.7);
    padding: 1px 3px;
    border-radius: 4px;
  }
  
  button, select { font-size:16px; padding:10px 20px; margin:8px; border-radius:6px; border:none; cursor:pointer; background:#ff6f61; color:#fff; font-weight:bold; transition:all 0.2s; box-shadow: 0 4px 0 #d64535; }
  button:hover, select:hover { transform:translateY(-2px); background:#ff856f; box-shadow: 0 6px 0 #d64535; }
  button:active { transform:translateY(2px); box-shadow: 0 1px 0 #d64535; }
  
  #info { margin-top:15px; font-size:20px; font-weight:bold; color:#ffe600; min-height: 1.2em; text-shadow: 0 0 5px #ff0; }
  
  @media(max-width:500px){
    .column { width:54px; height:150px; padding:2px; }
    .cell { width:50px; height:50px; font-size:20px; border-radius:10px; }
    .grid { gap: 5px; }
  }
</style>
</head>
<body>

<h1>üé∞ Neon Slot</h1>
<p><strong>Balance:</strong> ‚Ç¨<span id="balance">1000.00</span></p>
<label><strong>Bet:</strong> <select id="bet"></select></label>
<br>
<button id="spinBtn" onclick="spin()">SPIN</button>
<button onclick="resetBalance()">RESET BALANCE</button>

<div class="grid" id="grid"></div>
<p id="info"></p>

<script>
const symbols = ['A','B','C','D'];
const balanceKey = 'slotBalance';
let balance = parseFloat(localStorage.getItem(balanceKey)) || 1000;
document.getElementById('balance').innerText = balance.toFixed(2);

// Polnjenje izbire stave
const betSelect = document.getElementById('bet');
for(let b=0.1; b<=1; b+=0.1){ 
    let opt=document.createElement('option'); 
    opt.value=b.toFixed(2); 
    opt.textContent="‚Ç¨"+b.toFixed(2); 
    betSelect.appendChild(opt); 
}

// Inicializacija mre≈æe
function createGrid(){    
    const grid = document.getElementById('grid'); 
    grid.innerHTML='';    
    for(let c=0; c<5; c++){        
        const col=document.createElement('div'); 
        col.className='column';        
        const reel=document.createElement('div'); 
        reel.className='reel';        
        for(let r=0; r<3; r++){            
            const cell=document.createElement('div'); 
            cell.className='cell'; 
            cell.innerText=symbols[Math.floor(Math.random()*symbols.length)];            
            reel.appendChild(cell);        
        }        
        col.appendChild(reel);        
        grid.appendChild(col);    
    }
}
createGrid();

let isSpinning = false;

function spin(){    
    if(isSpinning) return;
    
    const bet = parseFloat(betSelect.value);    
    if(bet > balance){ alert("Ni dovolj denarja"); return; }    
    
    isSpinning = true;
    balance -= bet;    
    document.getElementById('balance').innerText = balance.toFixed(2);
    document.getElementById('info').innerText = 'Spinning...';
    
    const columns = document.querySelectorAll('.column');    
    // Matrika za logiko (3 vrstice, 5 stolpcev)
    let finalGrid = Array.from({length:3}, () => Array(5).fill(null));    
    
    columns.forEach((col, c) => {        
        const reel = document.createElement('div');         
        reel.className = 'reel';         
        col.innerHTML = '';         
        col.appendChild(reel);        
        
        // 1. Generiramo dolg seznam nakljuƒçnih simbolov za animacijo
        let longSymbols = [];        
        for(let i=0; i<20; i++){ 
            longSymbols.push(symbols[Math.floor(Math.random()*symbols.length)]); 
        }        
        
        // 2. Doloƒçimo ZADNJE 3 simbole, ki bodo rezultat
        let visible = [];        
        for(let r=0; r<3; r++){            
            let isX = Math.random() < 0.02;            
            let val;            
            if(isX){ 
                const roll = Math.random(); 
                if(roll<0.4) val='2X'; 
                else if(roll<0.65) val='3X'; 
                else if(roll<0.85) val='5X'; 
                else if(roll<0.97) val='10X'; 
                else val='100X'; 
            } else {
                val = symbols[Math.floor(Math.random()*symbols.length)];            
            }
            visible.push(val); 
            // Shranimo v logiƒçno mre≈æo: r=vrstica, c=stolpec
            finalGrid[r][c] = val;        
        }        
        
        // Zdru≈æimo vse simbole: najprej polnilni, nato konƒçni
        const allSymbols = [...longSymbols, ...visible];        
        
        allSymbols.forEach(sym => {            
            const cell = document.createElement('div'); 
            cell.className = 'cell'; 
            cell.innerText = sym;            
            if(sym.includes('X')) cell.classList.add('x');            
            reel.appendChild(cell);        
        });        
        
        // Spro≈æimo animacijo
        // Force reflow
        reel.offsetHeight;        
        reel.style.transition = 'transform 2.5s cubic-bezier(.15,.9,.25,1)';        
        
        // Vi≈°ina celice je 80px (ali 50px na mobitelu). Raƒçunamo glede na ≈°irino okna.
        const cellHeight = window.innerWidth <= 500 ? 50 : 80;
        
        // Premaknemo tako, da so vidni samo zadnji 3
        const offset = (allSymbols.length - 3) * cellHeight; 
        reel.style.transform = `translateY(-${offset}px)`;    
    });    
    
    // Poƒçakamo konec animacije
    setTimeout(() => { 
        // 1. Najprej poƒçistimo DOM, da ostanejo samo zadnje 3 celice
        showFinalCells(); 
        // 2. Nato izraƒçunamo dobitke na teh celicah
        calculateWin(finalGrid, bet); 
        isSpinning = false;
    }, 2500);
}

// Funkcija, ki odstrani vse celice razen zadnjih treh in resetira transform
function showFinalCells(){    
    const columns = document.querySelectorAll('.column');    
    columns.forEach(col => {        
        const reel = col.querySelector('.reel');        
        const cells = Array.from(reel.children);        
        
        // Vzamemo samo zadnje 3
        const last3 = cells.slice(-3);        
        
        reel.innerHTML = '';        
        last3.forEach(c => reel.appendChild(c));        
        
        // Resetiramo stil, ker so zdaj v reel-u samo te 3 celice na vrhu
        reel.style.transition = 'none';        
        reel.style.transform = 'translateY(0)';    
    });
}

function calculateWin(grid, bet){    
    let multiplier = 0; 
    let cellWins = {}; 
    let clusters = [];    
    
    // Preveri multiplikatorje
    for(let r=0; r<3; r++){ 
        for(let c=0; c<5; c++){ 
            if(grid[r][c].includes('X')) multiplier += parseInt(grid[r][c].replace('X','')); 
        } 
    }    
    if(multiplier === 0) multiplier = 1;    
    
    let visited = Array.from({length:3}, () => Array(5).fill(false));    
    
    // Depth First Search za iskanje grup
    function dfs(r, c, symbol, cluster){ 
        if(r<0 || r>=3 || c<0 || c>=5 || visited[r][c] || grid[r][c] !== symbol) return; 
        visited[r][c] = true; 
        cluster.push([r,c]); 
        dfs(r+1,c,symbol,cluster); 
        dfs(r-1,c,symbol,cluster); 
        dfs(r,c+1,symbol,cluster); 
        dfs(r,c-1,symbol,cluster); 
    }    
    
    for(let r=0; r<3; r++){        
        for(let c=0; c<5; c++){            
            if(!visited[r][c] && !grid[r][c].includes('X')){                
                let cluster = []; 
                dfs(r, c, grid[r][c], cluster);                
                if(cluster.length >= 4){ 
                    clusters.push({cells: cluster}); 
                    cluster.forEach(([rr, cc]) => { 
                        const base = grid[rr][cc] === 'A' ? bet * 0.5 : bet * 0.1; 
                        cellWins[rr + '-' + cc] = base; 
                    }); 
                }            
            }        
        }    
    }    
    
    const columns = document.querySelectorAll('.column');
    
    clusters.forEach(cl => { 
        cl.cells.forEach(([r, c]) => {        
            // POZOR: grid je [row][col], HTML je Column -> Cell[row]
            // Zato najprej izberemo stolpec C, nato njegovo R-to celico
            const reel = columns[c].querySelector('.reel');
            const targetCell = reel.children[r];
            
            if(targetCell) {
                targetCell.classList.add('win');         
                const span = document.createElement('span'); 
                span.className = 'subwin'; 
                span.innerText = '‚Ç¨' + (cellWins[r + '-' + c] * multiplier).toFixed(2); 
                targetCell.appendChild(span);    
            }
        }); 
    });    
    
    let baseWin = Object.values(cellWins).reduce((a,b) => a+b, 0);    
    let win = baseWin * multiplier; 
    
    if(win > 0) {
        balance += win; 
        localStorage.setItem(balanceKey, balance);    
        document.getElementById('balance').innerText = balance.toFixed(2);    
        document.getElementById('info').innerText = `WIN: ‚Ç¨${win.toFixed(2)} (Mult: x${multiplier})`;
    } else {
        document.getElementById('info').innerText = "Good luck next time!";
    }
}

function resetBalance(){ 
    balance = 1000; 
    localStorage.setItem(balanceKey, balance); 
    document.getElementById('balance').innerText = balance.toFixed(2); 
    document.getElementById('info').innerText = 'Balance resetiran'; 
    createGrid(); 
}
</script>
</body>
</html>
